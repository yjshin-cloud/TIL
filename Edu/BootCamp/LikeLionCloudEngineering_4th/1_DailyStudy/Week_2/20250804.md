# Java 객체지향 프로그래밍 완전 정복 가이드 ☕

> 멋쟁이 사자처럼 5일차 강의 정리 (2025.08.04)  


## 🎯 객체지향 프로그래밍이란?

객체지향 프로그래밍(OOP)은 **현실 세계의 사물**을 프로그램에서 **객체**로 모델링하는 프로그래밍 패러다임입니다.

```mermaid
mindmap
  root((OOP 핵심 개념))
    캡슐화
      데이터 은닉
      접근 제어
      정보 보호
    
    상속
      코드 재사용
      계층 구조
      is-a 관계
    
    다형성
      메서드 오버라이딩
      인터페이스 구현
      런타임 바인딩
    
    추상화
      복잡성 숨기기
      인터페이스 제공
      구현 세부사항 분리
```

## 📊 Java OOP 클래스 계층 구조

### AI 챗봇 프로젝트를 통한 OOP 이해

```mermaid
classDiagram
    class IGemini {
        <<interface>>
        +chat(String message) String*
    }
    
    class Chatbot {
        <<abstract>>
        -final String apiKey
        -static final String GEMINI_URL
        -static final HttpClient client
        
        #Chatbot(String apiKey)
        +chat(String message) String
        -handleMessage(String message) String
        -callGemini(String apiKey, String text) String
        -changeResult(String result) String
    }
    
    class RoleChatbot {
        -final String role
        
        +RoleChatbot(String apiKey)
        +RoleChatbot(String apiKey, String role)
        +chat(String message) String
    }
    
    IGemini <|.. Chatbot : implements
    Chatbot <|-- RoleChatbot : extends
```

## 🏗 인터페이스 (Interface)

### IGemini 인터페이스 설계

```java
public interface IGemini {
    String chat(String message) throws Exception;
}
```

**인터페이스의 특징:**
- 모든 메서드는 기본적으로 `public abstract`
- 구현체에서 반드시 구현해야 함
- 다중 상속이 가능함
- **계약(Contract)** 역할을 함

```mermaid
graph TD
    A[IGemini Interface] --> B[계약 정의]
    B --> C[chat 메서드 규약]
    C --> D[모든 구현체는 이 규약을 따라야 함]
    
    style A fill:#e3f2fd
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
```

## 🎨 추상 클래스 (Abstract Class)

### Chatbot 추상 클래스 분석

```java
public abstract class Chatbot implements IGemini {
    // 공통 필드
    final String apiKey;
    
    // 생성자
    protected Chatbot(String apiKey) {
        this.apiKey = apiKey;
    }
    
    // 구현된 메서드 (템플릿 메서드 패턴)
    @Override
    public String chat(String message) throws Exception {
        String templateMessage = handleMessage(message);
        String geminiResponse = callGemini(apiKey, templateMessage);
        return changeResult(geminiResponse);
    }
    
    // private 메서드들...
}
```

**추상 클래스 vs 인터페이스:**

| 구분 | 추상 클래스 | 인터페이스 |
|------|-------------|-----------|
| 상속 | 단일 상속 | 다중 구현 |
| 메서드 | 구현된 메서드 + 추상 메서드 | 기본적으로 추상 메서드 |
| 필드 | 인스턴스 변수 가능 | static final만 가능 |
| 생성자 | 가능 | 불가능 |

## 🔄 템플릿 메서드 패턴

Chatbot 클래스의 `chat` 메서드는 **템플릿 메서드 패턴**을 사용합니다:

```mermaid
sequenceDiagram
    participant Client
    participant Chatbot
    participant RoleChatbot
    participant GeminiAPI
    
    Client->>RoleChatbot: chat("안녕하세요")
    RoleChatbot->>RoleChatbot: 빈 메시지 검증
    RoleChatbot->>Chatbot: super.chat(message + role)
    Chatbot->>Chatbot: handleMessage()
    Chatbot->>GeminiAPI: callGemini()
    GeminiAPI->>Chatbot: JSON 응답
    Chatbot->>Chatbot: changeResult()
    Chatbot->>RoleChatbot: 처리된 응답
    RoleChatbot->>Client: 최종 응답
```

## 👶 구체 클래스 (Concrete Class)

### RoleChatbot 클래스 구현

```java
public class RoleChatbot extends Chatbot {
    private final String role;
    
    // 기본 생성자
    RoleChatbot(String apiKey) {
        super(apiKey);
        this.role = "너는 위로를 위한 챗봇이야. 200자 이내로 감정적 위로를 위한 내용으로 답변해줘.";
    }
    
    // 역할 지정 생성자
    RoleChatbot(String apiKey, String role) {
        super(apiKey);
        this.role = role;
    }
    
    @Override
    public String chat(String message) throws Exception {
        if (message.trim().isEmpty()) {
            throw new Exception("빈 질문은 안 됩니다!");
        }
        return super.chat("%s. %s".formatted(message, role));
    }
}
```

**핵심 OOP 개념들:**

```mermaid
graph TD
    A[RoleChatbot] --> B[상속 Inheritance]
    A --> C[오버라이딩 Override]
    A --> D[캡슐화 Encapsulation]
    A --> E[생성자 오버로딩]
    
    B --> B1[Chatbot을 extends]
    C --> C1[chat 메서드 재정의]
    D --> D1[private final String role]
    E --> E1[2가지 생성자 제공]
    
    style A fill:#c8e6c9
    style B fill:#bbdefb
    style C fill:#f8bbd9
    style D fill:#ffe0b2
    style E fill:#d1c4e9
```

## 🌐 HTTP 통신과 API 연동

### Gemini API 연동 구조

```mermaid
flowchart LR
    A[사용자 입력] --> B[RoleChatbot]
    B --> C[메시지 + 역할 결합]
    C --> D[JSON 형태로 변환]
    D --> E[HTTP POST 요청]
    E --> F[Gemini API]
    F --> G[JSON 응답]
    G --> H[텍스트 추출]
    H --> I[사용자에게 반환]
    
    style F fill:#4caf50
    style B fill:#2196f3
```

### HTTP 요청 처리 코드 분석

```java
// 1. 메시지를 JSON 형태로 변환
private String handleMessage(String message) {
    return """
        {
            "contents": [
              {
                "parts": [
                  {
                    "text": "%s"
                  }
                ]
              }
            ]
        }
        """.formatted(message);
}

// 2. HTTP 요청 전송
private String callGemini(String apiKey, String text) throws IOException, InterruptedException {
    HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(GEMINI_URL))
            .headers("Content-Type", "application/json",
                    "X-goog-api-key", apiKey)
            .POST(HttpRequest.BodyPublishers.ofString(text))
            .build();
    
    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
    return response.body();
}

// 3. 응답에서 텍스트 추출
private String changeResult(String result) {
    return result
            .split("\"text\": \"")[1]
            .split("}")[0]
            .replace("\\n", "")
            .replace("\"", "")
            .trim();
}
```

## 🎮 실제 사용 예제

### GeminiVer3 메인 클래스

```java
public class GeminiVer3 {
    public static void main(String[] args) {
        // 환경변수에서 API 키 가져오기
        String apiKey = System.getenv("GEMINI_API_KEY");
        
        Scanner sc = new Scanner(System.in);
        System.out.print("당신과 상담할 사람을 서술해보세요 : ");
        
        // 동적으로 역할 설정
        Chatbot chatbot = new RoleChatbot(apiKey, 
            sc.nextLine() + "라고 설명된 사람이 대답하는 듯이 해줘.");
        
        // 대화 루프
        while (true) {
            System.out.print("질문을 입력하세요 : ");
            String question = sc.nextLine();
            
            if (question.equals("종료")) {
                System.out.println("대화 종료");
                return;
            }
            
            try {
                String resp = chatbot.chat(question);
                System.out.println(resp);
            } catch (Exception e) {
                System.err.println(e.getMessage());
            }
        }
    }
}
```

## 🛠 개발 도구와 AI 활용

### 추천 AI 개발 도구들

```mermaid
graph TD
    A[AI 코딩 도구] --> B[Gemini Code Assist]
    A --> C[GitHub Copilot]
    A --> D[Claude AI]
    
    B --> E[일일 6,000 코드 요청]
    B --> F[240 채팅 요청]
    
    C --> G[IDE 통합]
    C --> H[실시간 코드 완성]
    
    D --> I[코드 리뷰]
    D --> J[아키텍처 설계]
    
    style A fill:#e3f2fd
    style B fill:#c8e6c9
    style C fill:#fff3e0
    style D fill:#f3e5f5
```

### 추가 API 서비스들
- **[Together AI](https://api.together.ai/)**: 다양한 오픈소스 모델
- **[Groq](https://groq.com/)**: 초고속 추론 서비스
- **[OpenRouter](https://openrouter.ai/models?q=free)**: 무료 모델 제공

## 🎓 OOP 설계 원칙 (SOLID)

```mermaid
graph TD
    A[SOLID 원칙] --> B[S - Single Responsibility]
    A --> C[O - Open/Closed]
    A --> D[L - Liskov Substitution]
    A --> E[I - Interface Segregation]
    A --> F[D - Dependency Inversion]
    
    B --> B1[한 클래스는 하나의 책임만]
    C --> C1[확장에는 열려있고 수정에는 닫혀있어야]
    D --> D1[자식 클래스는 부모 클래스를 대체할 수 있어야]
    E --> E1[클라이언트는 사용하지 않는 인터페이스에 의존하면 안됨]
    F --> F1[상위 모듈은 하위 모듈에 의존하면 안됨]
    
    style A fill:#ff9800
    style B fill:#4caf50
    style C fill:#2196f3
    style D fill:#9c27b0
    style E fill:#f44336
    style F fill:#607d8b
```

## 🔍 예외 처리와 에러 핸들링

### throws vs try-catch 패턴

```java
// 1. throws로 예외 전파
public String chat(String message) throws Exception {
    // 호출하는 쪽에서 예외 처리 책임
}

// 2. try-catch로 예외 처리
try {
    String resp = chatbot.chat(question);
    System.out.println(resp);
} catch (Exception e) {
    System.err.println(e.getMessage());
}
```

**예외 처리 전략:**

```mermaid
flowchart TD
    A[예외 발생] --> B{예외 타입}
    
    B --> C[체크 예외]
    B --> D[언체크 예외]
    
    C --> E[반드시 처리해야 함]
    D --> F[선택적 처리]
    
    E --> G[try-catch 또는 throws]
    F --> H[RuntimeException 계열]
    
    style C fill:#ff5722
    style D fill:#ff9800
```

## 🚀 실습 프로젝트 확장 아이디어

### 1. 다양한 챗봇 타입 구현

```java
// 번역 전문 챗봇
public class TranslatorBot extends Chatbot {
    private final String targetLanguage;
    // 구현...
}

// 코딩 튜터 챗봇  
public class CodingTutorBot extends Chatbot {
    private final String programmingLanguage;
    // 구현...
}
```

### 2. 챗봇 팩토리 패턴

```mermaid
classDiagram
    class ChatbotFactory {
        +createChatbot(String type, String apiKey) Chatbot
    }
    
    class ChatbotType {
        <<enumeration>>
        ROLE
        TRANSLATOR
        TUTOR
        COUNSELOR
    }
    
    ChatbotFactory --> ChatbotType
    ChatbotFactory --> Chatbot
```

### 3. 대화 히스토리 관리

```java
public class ConversationManager {
    private List<Message> history;
    private Chatbot chatbot;
    
    public void addMessage(String user, String content) {
        history.add(new Message(user, content, LocalDateTime.now()));
    }
    
    public void saveToFile(String filename) throws IOException {
        // 대화 내역을 파일로 저장
    }
}
```

## 📚 학습 리소스 및 다음 단계

### 추천 학습 자료
- **[Java 공식 문서](https://docs.oracle.com/javase/)**: 기본 개념 정리
- **[Effective Java](https://www.oreilly.com/library/view/effective-java/9780134686097/)**: 고급 Java 기법
- **[Design Patterns](https://refactoring.guru/design-patterns)**: 디자인 패턴 학습

### 다음 학습 단계

```mermaid
timeline
    title Java OOP 학습 로드맵
    
    기초 단계    : 클래스와 객체
                : 상속과 다형성
                : 인터페이스와 추상클래스
    
    중급 단계    : 디자인 패턴
                : 예외 처리
                : 컬렉션 프레임워크
    
    고급 단계    : 멀티스레딩
                : 리플렉션
                : 제네릭과 람다
    
    실무 단계    : Spring Framework
                : JPA/Hibernate
                : 테스트 코드 작성
```

## 💡 핵심 포인트 요약

### OOP의 4대 원칙 실습 예제에서 확인

1. **📦 캡슐화**: `private` 필드와 `public` 메서드로 데이터 은닉
2. **🔗 상속**: `Chatbot` → `RoleChatbot` 계층 구조
3. **🎭 다형성**: 인터페이스를 통한 다양한 구현체 지원
4. **🎨 추상화**: 복잡한 API 통신을 간단한 `chat()` 메서드로 제공

### 실무에서 중요한 개념들

```mermaid
mindmap
  root((실무 핵심))
    예외 처리
      Checked Exception
      Unchecked Exception
      Custom Exception
    
    API 연동
      HTTP Client
      JSON 처리
      비동기 처리
    
    설계 패턴
      Template Method
      Factory Pattern
      Builder Pattern
    
    테스트
      Unit Test
      Integration Test
      Mock 객체
```

---

**Remember**: 객체지향 프로그래밍은 단순히 문법을 아는 것이 아니라, **현실 세계의 문제를 객체 간의 협력**으로 해결하는 사고방식입니다. 

*"좋은 설계는 변경에 유연하고, 확장 가능하며, 이해하기 쉬운 코드를 만듭니다!"* ✨
